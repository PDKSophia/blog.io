## 选择排序

### 算法思想

首先在未排序的数列中找到最小(or 最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or 最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

### 例子

以 [20, 40, 30, 10, 60, 50] 为例子

排序流程如下：

- 第 1 趟：i=0。找出 a[1...5]中的最小值 a[3]=10，然后将 a[0]和 a[3]互换。 数组变化：20,40,30,10,60,50 -- > 10,40,30,20,60,50

- 第 2 趟：i=1。找出 a[2...5]中的最小值 a[3]=20，然后将 a[1]和 a[3]互换。 数组变化：10,40,30,20,60,50 -- > 10,20,30,40,60,50

- 第 3 趟：i=2。找出 a[3...5]中的最小值，由于该最小值大于 a[2]，该趟不做任何处理。

- 第 4 趟：i=3。找出 a[4...5]中的最小值，由于该最小值大于 a[3]，该趟不做任何处理。

- 第 5 趟：i=4。交换 a[4]和 a[5]的数据。 数组变化：10,20,30,40,60,50 -- > 10,20,30,40,50,60

### 代码

```javascript
function selectSort(arr) {
  let minIndex; // 无序中最小元素位置
  for (let i = 0; i < arr.length; i++) {
    // 每一趟循环比较时，min用于存放较小元素的数组下标，这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。
    minIndex = i;

    //找 "a[i+1]..a[n]" 之间最小元素，并赋给minIndex
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        // 这里 < ，从小到大，如果是 > ，则从大到小
        minIndex = j;
      }
    }

    // 如果 minIndex !== i ，交换 arr[i] 和 arr[minIndex]
    // 交换了之后，保证了 arr[0] 到 arr[i] 之间元素有序
    if (minIndex !== i) {
      let temp = arr[minIndex];
      arr[minIndex] = arr[i];
      arr[i] = temp;
    }
  }
  return arr;
}

console.log(selectSort([20, 40, 30, 10, 60, 50])); // [ 10, 20, 30, 40, 50, 60 ]
```

### 时间复杂度

选择排序的时间复杂度是 O(N^2) ：假设被排序的数列中有 N 个数。遍历一趟的时间复杂度是 O(N)，需要遍历 N-1 次，因此，选择排序的时间复杂度是 O(N^2) 。无论数组原始排列如何，比较次数是不变的；对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动，
