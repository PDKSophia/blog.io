## Taro 框架基于 React 风格编写小程序优化版本设计

### 引入哪些必备依赖？解决了什么问题？

- redux 用于状态管理
- redux-logger 日志中间件，用于在控制台输出 redux 状态
- redux-thunk 异步操作中间件
- eslint 用于检验代码风格规范
- prettier 用于自动化补全代码，方便开发
- husky 在 git 提交时规范化 git 操作

### 优化点

- 小程序采用分包处理，在初次进入小程序最先加载主包，目的在于减少进入首页的等待时间 ⌛️ 优化性能，同时采用分包预加载，在网络下预加载其他分包

- 将常用的系统变量，如获取设备信息等数据，在小程序主 app.js 中缓存在本地，同时封装方法用户获取，实现统一

- 根据 React.Fragments 特性，由于 React 组件都需要一个根结点，而采用 Fragments 无需新增 DOM 节点，小程序方面采用 Block ，减少一层 DOM，加快渲染

- 根据 React 特性，只要 state / props 改变，就会从当前组件，触发 re-render，使得页面重新渲染，于是封装一个 List 组件(继承于 PureComponent)，只要给 List 组件传递一个 list 数组，只要内存地址不改变 (name = 1 >> name = 2，不会导致重新渲染)，原因是: react 是浅比较，比较的是内存地址

- 抛弃 scss，使用 css module 模块化思想，目的是: 避免 css 样式重叠导致出现覆盖问题，同时减少嵌套，因为 CSS 嵌套层次过深，会影响页面的渲染(具体请看浏览器渲染原理)

- 采用 preload 预加载，分为包的预加载 / 资源预加载 / react this.\$preload

  - 包预加载 (第一条优化点)

  - 资源预加载 : 由于前一个版本，在做到下一题时，才会获取当前的资源如 audio、radio、img 等资源路径，并且需要采用 setTimeout 实现自动播放，如果网络过慢，会导致无法播放音频或加载中，于是在资源这里，采用 preload 提前预加载下一题所需要的资源

  - react this.$preload : 统一页面之间传递数据的格式，页面之间可以承载资源，简化url的长度，之前页面传递资源通过query params，例如现在A通过this.$preload 传递某些资源，在 B 页面、C 页面直接通过 this.\$router.preload 可获取数据，而不需要在 A->B、A->C 中的 url 传递

- 减少 state 的引用，因为 state 改变会导致 re-render， 将一些不影响 UI 改变的属性绑定在 this 对象上

- 大幅度采用 async / await ，将异步变为同步，使得代码逻辑清晰，解决异步带来的代码嵌套层次过深问题及解决请求时间太久，代码继续执行，而 await 之后会等待此请求的返回

- 统一封装请求错误函数 showErrorModal，由于小程序自身异步返回 catch、Promise 可能返回 reject 或 catch ，于是封装一个统一函数，处理所有的错误并显示。配合 async / await ，在 try {} catch (err) {} 中，不用在乎是小程序的 catch 或者 promise 的错误，都会被 showErrorModal 函数处理

- 对后端返回的树状型数据进行扁平化处理，进行一个优化抽离，剔除不需要的数据，将所需的数据构造成自己需要的格式，因为如果后端返回的是一个树状级结构，在小程序中，逻辑层和视图层间的数据传递，是逻辑层将数据序列化后，传给视图层，视图层再反序列化，如果层次过深，会影响性能。同时剔除不需要的数据原因也是为了减少 redux 在比较的 list 数据时，层次过深，在 diff 比较时会增加比较时间

- 音频对象池的引入和设计

- 不影响布局的图片通过 css background-image 设为背景图，同时设置 background-position 进行设置图片的位置，使得 DOM 层不需要 image 标签，较少一层，优化性能，同时多用伪类实现如分割线、小三角之类的样式

- 采用策略模式，避免过多 if ... else 带来的复杂问题

### 设计点

- 为什么引入对象池？解决了什么问题？

- redux 在数据结构上的设计？

- 如何减少小程序的包大小？

- 全局 request 的设计 ？

- utils 中一些代码函数的封装，为什么这样封装？

- hangleUrl 是如何判断是请求接口还是只是拼接 url 图片地址？
