## 针对 Web 的攻击技术 XSS 与 CSRF

HTTP 协议内并不具备 `会话(session)管理`、`加密处理`等安全性方面的功能。在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由的变更、篡改。所以 Web 应用可能会接收到与预期数据不相同的内容。

在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全泄漏，那内部信息就会遭到窃取，或者被攻击者拿到管理权限

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-35.png' width=520 height=320>

对 Web 应用对攻击模式有两种 :

- 主动攻击

- 被动攻击

### 以服务器为目标的主动攻击

主动攻击是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上对的资源进行攻击，因此攻击者需要能够访问到那些资源，主动攻击模式里，最具有代表性的是 : `SQL注入攻击` 和 `OS命令注入攻击`

### 以服务器为目标的被动攻击

被动攻击是指利用圈套策略执行攻击代码的攻击模式，通常都是诱导用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。执行完攻击代码之后，可能会导致用户所持有的 Cookie 等个人信息被窃取，登陆状态中的用户权限遭到恶意滥用等后果

被动攻击模式最具有代表性的是 : `跨站脚本攻击（XSS）`和 `跨站请求伪造（CSRF）`

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-36.png' width=520 height=320>

### 利用用户身份攻击企业内部网络

利用被动攻击，可发起对原本从互联网上无法直接访问的企业内部等网络的攻击。只要用户踏入攻击者预先设定好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。

---

### 使用 XSS 攻击

xss 叫做跨站脚本攻击，是一种 web 应用中的计算机漏洞，当用户浏览器渲染整个 HTML 文档的过程中出现了不被预期的脚本指令并执行时，XSS 就会发生。(这个逼装的好，鼓个掌)

它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。

#### XSS 分为三种

```base
反射型XSS : 这种xss，跨站代码一般存在于某一个链接中，当被攻击者访问这样的连接时，跨站代码就被执行，这类跨站代码一般不会存储在服务器上面
```

```base
存储型XSS : 这种xss用起来比较方便，跨站代码会存储在服务器上面数据库中，换句话就是可以持久的进行攻击，亦称持久型XSS
```

```基于DOM的XSS
基于DOM的XSS : 这是由于客户端脚本自身的解析不正确导致的安全问题
```

#### 如何攻击 ？

XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。

```html
<!-- 比如在一个留言板中插入xss代码，前提是留言内容不过滤 -->

<!-- 在文本框中添加 -->
<script>
  alert('我是XSS攻击');
</script>

<!-- 这时候点击留言，脚本被执行，就会弹出对话框，这就说明存在XSS危害 -->
```

#### 如何预防 ？

最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

```javascript
function escape(str) {
  str = str.replace(/&/g, '&amp;');
  str = str.replace(/</g, '&lt;');
  str = str.replace(/>/g, '&gt;');
  str = str.replace(/"/g, '&quto;');
  str = str.replace(/'/g, '&##39;');
  str = str.replace(/`/g, '&##96;');
  str = str.replace(/\//g, '&##x2F;');
  return str;
}

// 通过转义，将攻击代码变成
escape('<script>alert(1)</script>');
// &lt;script&gt;alert(1)&lt;&##x2F;script&gt;
```

---

### CSRF 跨站请求伪造

你可以这样理解 : 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

#### 我们是实在人，举个实在例子

受害者 A 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=A&amount=1000000&for=B 可以使 A 把 1000000 的存款转到 B 的账号下。

通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。

黑客 B 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=A&amount=1000000&for=B。 但是这个请求来自 B 而非 A，他不能通过安全认证，因此该请求不会起作用。

这时，B 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=A&amount=1000000&for=B ”，并且通过广告等诱使 A 来访问他的网站。

当 A 访问该网站时，上述 url 就会从 A 的浏览器发向银行，而这个请求会附带 A 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 A 的认证信息。

但是！！！如果 A 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 A 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 A 的账号转移到 B 的账号，而 A 当时毫不知情。

等以后 A 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 B 则可以拿到钱后逍遥法外。

#### 如何防御

```base
    1 、 验证 HTTP Referer 字段；Referer 来判断该请求是否为第三方网站发起的

    2 、 在请求地址中添加 token 并验证；由服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

    3 、 在 HTTP 头中自定义属性并验证。可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击
```

---

### SQL 注入攻击

SQl 注入攻击是指针对 Web 应用使用的数据库，通过运行非法的 SQL 语句而产生的攻击。正常情况下：从 book 表中搜索作者 author = 'PDK' 且 flag = 1 的符合数据

```javascript
  URL: http://www.pengdaokuan.cn/search?q=PDK
```

然后在 SQL 语句为:

```sql
  SELECT * FROM book WHERE author = 'PDK' and flag = 1;
```

但是如果通过把查询字段改为： `PDK` -> `PDK--`
那么构成的 SQl 语句就变成了这样

```sql
  SELECT * FROM book WHERE author = 'PDK' --' and flag = 1;
```

SQL 语句中的`--`之后全视为注释，即，and flag = 1 这个条件被自动忽略了！

---

### HTTP 首部注入攻击

HTTP 首部注入攻击是值攻击者通过在响应首部字段内插入换行，添加任意响应首部或者主体的一种攻击。输入被动攻击模式

向首部主体内添加内容的攻击称为 HTTP 响应截断攻击，Web 应用有时会把外部接收到的数值，赋给响应首部字段 `Location` 和 `Set-Cookie`

```javascript
  Location: http://www.pengdaokuan.cn/a.php?q=pdk
  Set-Cookie: UID=pdk

  *pdk就是插入值
```

HTTP 首部注入攻击有可能会造成以下一些影响

- 设置任何 Cookie 信息

- 重定向至任意 URL

- 显示任意的主体(HTTP 响应截断攻击)

---

### 开放重定向

开放重定向是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指: 加入指定的重定向 URL 到某个恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。

---

### 会话劫持

是指通过某种手段拿到用户的会话 ID，并没法使用此会话 ID 伪装成用户，达到攻击的目的。

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-37.png' width=520 height=320>

具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理

下面列举几种攻击者可获得会话 ID 的途径

- 通过非正规的生成方法推测会话 ID

- 通过窃听或 XSS 攻击盗取会话 ID

- 通过会话固定攻击强行获取会话 ID

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-38.png' width=520 height=320>

---

### 其他安全漏洞

#### 密码破解

密码破解攻击即算出密码，突破认证。密码破解有以下两种手段:

- 通过网络的密码试错 (两种方式: 穷举法和字典攻击)

> 穷举法，又称为暴力破解法，是对所有密钥集合构成的密钥空间进行穷举，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击。比如银行采用“4 位数字”组成的密码，那么就要从 0000~9999 中的全部数字进行逐个尝试。这样必定能在候选的密码集合中找到正确的密码，可通过认证，但时间太久，这种攻击是失败的。

> 字典攻击，利用实现收集好的候选密码(通过各种组合方式后存入字典)，枚举字典中的密码。尝试通过认证的一种攻击手段。比如银行采用“4 位数字”组成的密码，考虑到用户可能会用自己的生日做密码，于是可以将 0101~1231 保存成字典，进行尝试。此方法攻击耗时相对穷举比较短，但是攻击的成败取决于字典的内容。如果字典中没有正确的密码，那么就无法破解成功

- 对已加密密码的破解

> web 应用在保存密码时，一般不会明文方式保存，而是通过散列函数做散列处理或者通过 base64，md5 等加密方式，所以想要取得真实密码，需要通过解码手段。把密码还原成明文形式。

<img src='https://github.com/PDKSophia/read-booklist/raw/master/book-image/http-39.png' width=520 height=320>

#### 点击劫持

点击劫持是值利用透明的按钮或链接做成陷阱，覆盖在 web 页面上，然后诱导用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing)
